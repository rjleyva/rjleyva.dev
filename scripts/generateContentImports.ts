#!/usr/bin/env node
import fs from 'fs'
import path from 'path'
import { fileURLToPath } from 'url'
import rehypeSlug from 'rehype-slug'
import rehypeStringify from 'rehype-stringify'
import remarkGfm from 'remark-gfm'
import remarkParse from 'remark-parse'
import remarkRehype from 'remark-rehype'
import { unified } from 'unified'
import { parse as parseYaml } from 'yaml'
import type { Post, PostFrontmatter } from '@/types/post'

interface ParsedFrontmatter {
  data: PostFrontmatter
  content: string
}

const __dirname = path.dirname(fileURLToPath(import.meta.url))
const contentDir = path.join(__dirname, '../src/content/blog')

// Create HTML processor for build-time markdown conversion
const createHtmlProcessor = (): ReturnType<typeof unified> => {
  return unified()
    .use(remarkParse)
    .use(remarkGfm)
    .use(remarkRehype, {
      allowDangerousHtml: true
    })
    .use(rehypeSlug)
    .use(rehypeStringify) as unknown as ReturnType<typeof unified>
}

// Convert markdown to HTML at build time
const markdownToHtml = (markdown: string): string => {
  const processor = createHtmlProcessor()
  const file = processor.processSync(markdown)
  return String(file)
}

// Parse frontmatter from markdown content
const parseFrontmatter = (fileContent: string): ParsedFrontmatter => {
  const frontmatterMatch = fileContent.match(/^---\n([\s\S]*?)\n---\n/)
  let data: PostFrontmatter = {
    title: '',
    date: '',
    description: '',
    tags: []
  }
  let content = fileContent
  if (frontmatterMatch?.[1] != null) {
    data = parseYaml(frontmatterMatch[1]) as PostFrontmatter
    content = fileContent.replace(/^---[\s\S]*?---\n/, '')
  }
  return { data, content }
}

// Scan the content directory for markdown files
const scanContentDirectory = (): string[] => {
  const files: string[] = []

  const scanDir = (dir: string, relativePath = ''): void => {
    const entries = fs.readdirSync(dir, { withFileTypes: true })

    for (const entry of entries) {
      const fullPath = path.join(dir, entry.name)
      const relPath = path.join(relativePath, entry.name)

      if (entry.isDirectory()) {
        scanDir(fullPath, relPath)
      } else if (entry.isFile() && entry.name.endsWith('.md')) {
        files.push(relPath)
      }
    }
  }

  scanDir(contentDir)
  return files
}

// Generate the content loader with processed posts
const generateContentLoader = (files: string[]): string => {
  const imports: string[] = []
  const modules: string[] = []
  const posts: Post[] = []

  for (const file of files) {
    const varName = file.replace(/[^a-zA-Z0-9]/g, '_') + '_content'
    const importPath = `@/content/blog/${file}?raw`

    imports.push(`import ${varName} from '${importPath}'`)
    modules.push(`  '@/content/blog/${file}': ${varName}`)

    // Read and process the file content
    const filePath = path.join(contentDir, file)
    const fileContent = fs.readFileSync(filePath, 'utf-8')
    const parsed = parseFrontmatter(fileContent)

    // Extract topic and slug from file path
    const pathParts = file.split('/')
    const topic = pathParts[pathParts.length - 2] ?? ''
    const fileName = pathParts[pathParts.length - 1] ?? ''
    const slug = fileName.replace('.md', '')

    // Generate HTML content
    const htmlContent = markdownToHtml(parsed.content)

    // Calculate reading time
    const words = parsed.content.split(/\s+/).length
    const readingTime = Math.ceil(words / 200)

    posts.push({
      title: parsed.data.title,
      date:
        parsed.data.date instanceof Date
          ? parsed.data.date
          : new Date(parsed.data.date),
      description: parsed.data.description,
      tags: parsed.data.tags ?? [],
      slug,
      topic,
      content: parsed.content,
      htmlContent,
      readingTime
    })
  }

  return `// Auto-generated content imports - do not edit manually
// Generated by scripts/generateContentImports.ts

${imports.join('\n')}

export const contentModules = {
${modules.join(',\n')}
}

// Pre-processed posts with HTML content
export const processedPosts = ${JSON.stringify(posts, null, 2)}
`
}

// Main execution
const files = scanContentDirectory()
const output = generateContentLoader(files)

const outputPath = path.join(
  __dirname,
  '../src/lib/content/generatedContent.ts'
)
fs.writeFileSync(outputPath, output)

console.log(`Generated content loader for ${files.length} files:`)
files.forEach(file => console.log(`  - ${file}`))
